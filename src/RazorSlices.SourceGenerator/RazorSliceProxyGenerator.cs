using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace RazorSlices.SourceGenerator;

[Generator]
internal class RazorSliceProxyGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var assemblyName = context.CompilationProvider.Select(static (compilation, _) => compilation.AssemblyName);

        var rootNamespace = context.AnalyzerConfigOptionsProvider.Select(static (options, _) =>
            options.GlobalOptions.TryGetValue("build_property.RootNamespace", out var rootNamespace) ? rootNamespace : null);

        var projectDirectory = context.AnalyzerConfigOptionsProvider.Select(static (options, _) =>
            options.GlobalOptions.TryGetValue("build_property.MSBuildProjectDirectory", out var projectDir) ? projectDir : null);

        // (Left.Left          , (Left.Right.Left     , Left.Right.Right.......))
        // (string assemblyName, (string rootNamespace, string projectDirectory))
        var projectInfo = assemblyName.Combine(rootNamespace.Combine(projectDirectory));

        var texts = context.AdditionalTextsProvider
            .Where(text => text.Path.EndsWith(".cshtml", StringComparison.OrdinalIgnoreCase)
                           && !text.Path.EndsWith("_ViewImports.cshtml", StringComparison.OrdinalIgnoreCase)
                           && !text.Path.EndsWith("_ViewStart.cshtml", StringComparison.OrdinalIgnoreCase));

        // (() projectInfo, texts)
        var combined = projectInfo.Combine(texts.Collect());
        
        context.RegisterSourceOutput(combined, static (spc, pair) => Execute(spc, pair.Left.Left, pair.Left.Right.Left, pair.Left.Right.Right, pair.Right));
    }

    private static void Execute(SourceProductionContext context, string? assemblyName, string? rootNamespace, string? projectDirectory, ImmutableArray<AdditionalText> texts)
    {
        if (string.IsNullOrEmpty(rootNamespace) || string.IsNullOrEmpty(projectDirectory))
        {
            // Need to have a root namespace and project directory to generate the code
            return;
        }

        var distinctTexts = texts.Distinct();

        if (!distinctTexts.Any())
        {
            // Nothing to do yet
            return;
        }

        HashSet<string> generatedClasses = [];

        var codeBuilder = new StringBuilder();

        codeBuilder.AppendLine("// <auto-generated/>");
        codeBuilder.AppendLine();
        codeBuilder.AppendLine("using global::System.Diagnostics.CodeAnalysis;");
        codeBuilder.AppendLine("using global::RazorSlices;");
        codeBuilder.AppendLine();
        codeBuilder.AppendLine("#nullable enable");
        codeBuilder.AppendLine();

        codeBuilder.AppendLine($$"""
            namespace {{rootNamespace}}
            {
                /// <summary>
                /// All calls to create Razor Slices instances via the generated <see cref="global::RazorSlices.IRazorSliceProxy"/> classes
                /// go through this factory to ensure that the generated types' Create methods are always invoked via the static abstract
                /// methods defined in the <see cref="global::RazorSlices.IRazorSliceProxy"/> interface. This ensures that the interface
                /// implementation is never trimmed from the generated types.
                /// </summary>
                /// <remarks>
                /// Workaround for https://github.com/dotnet/runtime/issues/102796
                /// </remarks>
                [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)] // Hide from IntelliSense.
                internal static class RazorSlicesGenericFactory
                {
                    public static RazorSlice CreateSlice<TProxy>() where TProxy : IRazorSliceProxy => TProxy.CreateSlice();
        
                    public static RazorSlice<TModel> CreateSlice<TProxy, TModel>(TModel model) where TProxy : IRazorSliceProxy => TProxy.CreateSlice(model);
                }
            }
            """);

        foreach (var file in distinctTexts)
        {
            var fileName = Path.GetFileNameWithoutExtension(file.Path);
            var directory = Path.GetDirectoryName(file.Path);
            var relativeFilePath = PathUtils.GetRelativePath(projectDirectory!, file.Path);
            var relativeDirectoryPath = PathUtils.GetRelativePath(projectDirectory!, directory);
            var subNamespace = relativeDirectoryPath == "."
                ? ""
                : relativeDirectoryPath.Replace(Path.DirectorySeparatorChar, '.');

            var className = fileName;

            if (!CSharpHelpers.IsValidTypeName(className))
            {
                className = CSharpHelpers.CreateValidTypeName(className);
            }

            if (!string.IsNullOrEmpty(subNamespace) && !CSharpHelpers.IsValidNamespace(subNamespace))
            {
                subNamespace = CSharpHelpers.CreateValidNamespace(subNamespace);
            }

            var subNamespaceAsClassName = subNamespace.Replace('.', '_');
            var fullNamespace = string.IsNullOrEmpty(subNamespace)
                ? rootNamespace
                : $"{rootNamespace}.{subNamespace}";

            // Duplicate class name check

            if (generatedClasses.Contains($"{fullNamespace}.{className}"))
            {
                // TODO: Add an integer suffix to the class name so it can be generated and then log a warning?
                var descriptor = new DiagnosticDescriptor(
                    "RSG0001",
                    "Duplicate Class Name",
                    $"Generated class with name {className} already exists. File '{relativeFilePath}' has been ignored.",
                    "Naming",
                    DiagnosticSeverity.Warning,
                    true);

                context.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None));
            }
            else
            {
                generatedClasses.Add($"{fullNamespace}.{className}");

                codeBuilder.AppendLine($$"""
                namespace {{fullNamespace}}
                {
                """);

                var generatedTypeName = string.IsNullOrEmpty(subNamespaceAsClassName)
                    ? className
                    : $"{subNamespaceAsClassName}_{className}";

                codeBuilder.AppendLine($$"""
                    /// <summary>
                    /// Static proxy for the Razor Slice defined in <c>{{relativeFilePath}}</c>.
                    /// </summary>
                    public sealed class {{className}} : global::RazorSlices.IRazorSliceProxy
                    {
                        [global::System.Diagnostics.CodeAnalysis.DynamicDependency(global::System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All, TypeName, "{{assemblyName}}")]
                        private const string TypeName = "AspNetCoreGeneratedDocument.{{generatedTypeName}}, {{assemblyName}}";
                        [global::System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(global::System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All)]
                        private static readonly global::System.Type _sliceType = global::System.Type.GetType(TypeName)
                            ?? throw new global::System.InvalidOperationException($"Razor view type '{TypeName}' was not found. This is likely a bug in the RazorSlices source generator.");
                        private static readonly global::RazorSlices.SliceDefinition _sliceDefinition = new(_sliceType);

                        /// <summary>
                        /// Creates a new instance of the Razor Slice defined in <c>{{relativeFilePath}}</c> .
                        /// </summary>
                        public static global::RazorSlices.RazorSlice Create()
                            => global::{{rootNamespace}}.RazorSlicesGenericFactory.CreateSlice<global::{{fullNamespace}}.{{className}}>();

                        /// <summary>
                        /// Creates a new instance of the Razor Slice defined in <c>{{relativeFilePath}}</c> with the given model.
                        /// </summary>
                        public static global::RazorSlices.RazorSlice<TModel> Create<TModel>(TModel model)
                            => global::{{rootNamespace}}.RazorSlicesGenericFactory.CreateSlice<global::{{fullNamespace}}.{{className}}, TModel>(model);

                        // Explicit interface implementation
                        static global::RazorSlices.RazorSlice global::RazorSlices.IRazorSliceProxy.CreateSlice() => _sliceDefinition.CreateSlice();

                        // Explicit interface implementation
                        static global::RazorSlices.RazorSlice<TModel> global::RazorSlices.IRazorSliceProxy.CreateSlice<TModel>(TModel model) => _sliceDefinition.CreateSlice(model);
                    }
                """);

                codeBuilder.AppendLine("}");

                codeBuilder.AppendLine();
            }
        }

        context.AddSource($"{rootNamespace}.RazorSliceProxies.g.cs", SourceText.From(codeBuilder.ToString(), Encoding.UTF8));
    }
}

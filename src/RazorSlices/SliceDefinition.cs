using System.Diagnostics.CodeAnalysis;
using System.Reflection;

namespace RazorSlices;

/// <summary>
/// Defines a Razor Slice that can be created via <see cref="RazorSliceFactory"/>.
/// </summary>
/// <remarks>
/// This type is used by the types generated by the Razor Slices source generator. You should not need to interact with this type directly in your project.
/// </remarks>
public sealed class SliceDefinition
{
    private readonly Func<object, RazorSlice> _factoryWithModel;
    private readonly Func<RazorSlice> _factoryNoModel;
    private readonly bool _hasLayout;

    /// <summary>
    /// Creates a new instance of <see cref="SliceDefinition"/>.
    /// </summary>
    /// <param name="sliceType">The type of the slice.</param>
    /// <param name="sliceFilePath"></param>
    /// <exception cref="ArgumentException">Thrown if the specified slice type cannot be loaded.</exception>
    public SliceDefinition(
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
        Type sliceType,
        string sliceFilePath)
    {
        ArgumentNullException.ThrowIfNull(sliceType);

        SliceType = sliceType;
        SliceFilePath = sliceFilePath;
        HasModel = RazorSliceFactory.IsModelSlice(SliceType);
        _hasLayout = sliceType.IsAssignableTo(typeof(IUsesLayout));
        //var layoutTypeValid = !_hasLayout || RazorSliceFactory.GetLayoutTypes(SliceType).LayoutType.IsAssignableTo(typeof(IRazorLayoutSlice));
        ModelProperty = SliceType.GetProperty("Model");
        ModelType = ModelProperty?.PropertyType;
        InjectableProperties = RazorSliceFactory.GetInjectableProperties(SliceType);

        //var factory = sliceType.IsAssignableTo(typeof(RazorSlice)) && layoutTypeValid
        //    ? RazorSliceFactory.GetSliceFactory(this)
        //    : layoutTypeValid
        //        ? InvalidSliceType
        //        : InvalidLayoutSliceType;

        var factory = sliceType.IsAssignableTo(typeof(RazorSlice))
            ? RazorSliceFactory.GetSliceFactory(this)
            : InvalidSliceType;
        _factoryNoModel = HasModel
            ? SliceRequiresModel
            : (Func<RazorSlice>)factory;
        _factoryWithModel = !HasModel
            ? InvalidModelType
            : (Func<object, RazorSlice>)factory;
    }

    /// <summary>
    /// Gets the type of the slice.
    /// </summary>
    [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
    public Type SliceType { get; }

    /// <summary>
    /// Gets the project-relative file path of the slice.
    /// </summary>
    public string SliceFilePath { get; }

    /// <summary>
    /// Gets whether this slice has a model.
    /// </summary>
    public bool HasModel { get; }

    /// <summary>
    /// Gets the information about the model property for the slice if it has a model.
    /// </summary>
    public PropertyInfo? ModelProperty { get; }

    /// <summary>
    /// Gets the model type for the slice if it has a model.
    /// </summary>
    public Type? ModelType { get; }

    /// <summary>
    /// Gets details of the injectable properties for the slice.
    /// </summary>
    public (bool Any, PropertyInfo[] Nullable, PropertyInfo[] NonNullable) InjectableProperties { get; }

    ///// <summary>
    ///// Gets the factory delegate for creating instances of the slice.
    ///// </summary>
    //public Delegate Factory { get; }

    /// <summary>
    /// Creates a new instance of the slice this definition represents.
    /// </summary>
    /// <returns>The slice instance.</returns>
    /// <exception cref="InvalidOperationException">Thrown if the slice requires a model.</exception>
    public RazorSlice CreateSlice() => _factoryNoModel();

    /// <summary>
    /// Creates a new instance of the slice this definition represents with the specified model.
    /// </summary>
    /// <typeparam name="TModel">The type of the slice model.</typeparam>
    /// <param name="model">The model for the slice.</param>
    /// <returns>The slice instance.</returns>
    /// <exception cref="InvalidOperationException">Thrown if the slice does not require a model or the model instance passed is not assignable to the model type the slice requires.</exception>
    public RazorSlice<TModel> CreateSlice<TModel>(TModel model) => (RazorSlice<TModel>)_factoryWithModel(model!);

    private RazorSlice SliceRequiresModel() => throw new InvalidOperationException($"Slice {SliceType.Name} defined in file '{SliceFilePath}' requires a model of type {ModelType?.Name}. Call Create<TModel>(TModel model) instead.");

    private RazorSlice InvalidModelType<TModel>(TModel model) =>
        throw new InvalidOperationException($"""
            Cannot use model of type {typeof(TModel).Name} with slice {SliceType.Name} defined in file '{SliceFilePath}'.
            {(HasModel ? $"Ensure the model is assignable to {ModelType!.Name}" : "It is not a strongly-typed slice.")}
            """);

    private void InvalidSliceType() => throw new InvalidOperationException($"Cannot create Razor Slice for file '{SliceFilePath}' because it doesn't derive from type {nameof(RazorSlice)}. Make sure to inherit from {nameof(RazorSlice)}, {nameof(RazorSlice)}<TModel>, {nameof(RazorLayoutSlice)}, or {nameof(RazorLayoutSlice)}<TModel>, e.g. @inherit RazorSlice");

    private void InvalidLayoutSliceType() => throw new InvalidOperationException($"Cannot create Razor Slice for file '{SliceFilePath}' because the layout it specifies via '@implements {nameof(IUsesLayout)}<TLayout>' or '@implements {nameof(IUsesLayout)}<TLayout, TLayoutModel>' does not inherit from {nameof(RazorLayoutSlice)} or {nameof(RazorLayoutSlice)}<TModel>.");
}

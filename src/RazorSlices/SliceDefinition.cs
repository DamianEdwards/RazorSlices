using System.Collections.Concurrent;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Reflection;

namespace RazorSlices;

/// <summary>
/// Defines a Razor Slice that can be created via <see cref="RazorSliceFactory"/>.
/// </summary>
/// <remarks>
/// This type is used by the types generated by the Razor Slices source generator. You should not need to interact with this type directly in your project.
/// </remarks>
public class SliceDefinition
{
    [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
    private readonly Type _originalSliceType;

    private ConcurrentQueue<RazorSlice>? _reusableInstances;

    /// <summary>
    /// Creates a new instance of <see cref="SliceDefinition"/>.
    /// </summary>
    /// <param name="sliceType">The type of the slice.</param>
    /// <exception cref="ArgumentException">Thrown if the specified slice type cannot be loaded.</exception>
    public SliceDefinition(
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
        Type sliceType)
    {
        ArgumentNullException.ThrowIfNull(sliceType);

        if (HotReloadService.IsSupported)
        {
            HotReloadService.ClearCacheEvent += ReplaceSliceType;
        }

        _originalSliceType = sliceType;
        Initialize(sliceType);
        Factory = RazorSliceFactory.GetSliceFactory(this);
    }

    [MemberNotNull(nameof(SliceType))]
    private void Initialize(
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
        Type sliceType)
    {
        SliceType = sliceType;
        IsReusable = sliceType.IsAssignableTo(typeof(IRazorReusableSlice));
        HasModel = RazorSliceFactory.IsModelSlice(SliceType);
        ModelProperty = SliceType.GetProperty("Model");
        ModelType = ModelProperty?.PropertyType;
        InjectableProperties = RazorSliceFactory.GetInjectableProperties(SliceType);
        Factory = RazorSliceFactory.GetSliceFactory(this);
    }

    [UnconditionalSuppressMessage("AssemblyLoadTrimming", "IL2067",
        Justification = "This method should only be called when a type is updated by the Hot Reload service and thus is fine for it to be" +
                        "trimmed during publish as Hot Reload doesn't run after publish anyway.")]
    private void ReplaceSliceType(Type[]? changedTypes)
    {
        var started = Stopwatch.GetTimestamp();

        if (HotReloadService.TryGetUpdatedType(changedTypes, _originalSliceType, out var updatedSliceType))
        {
            Debug.Write($"Hot reloading slice of type '{_originalSliceType.Name}'... ");

            _reusableInstances = null;
            Initialize(updatedSliceType);

            Debug.WriteLine($"done! It took {Stopwatch.GetElapsedTime(started).TotalMilliseconds}ms");
        }
    }

    /// <summary>
    /// Gets the type of the slice.
    /// </summary>
    [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]
    public Type SliceType { get; private set; }

    /// <summary>
    /// Gets whether this slice has a model.
    /// </summary>
    public bool HasModel { get; private set; }

    /// <summary>
    /// Gets the information about the model property for the slice if it has a model.
    /// </summary>
    public PropertyInfo? ModelProperty { get; private set; }

    /// <summary>
    /// Gets the model type for the slice if it has a model.
    /// </summary>
    public Type? ModelType { get; private set; }

    /// <summary>
    /// Gets details of the injectable properties for the slice.
    /// </summary>
    public (bool Any, PropertyInfo[] Nullable, PropertyInfo[] NonNullable) InjectableProperties { get; private set; }

    /// <summary>
    /// Gets the factory delegate for creating instances of the slice.
    /// </summary>
    public Delegate Factory { get; private set; }

    /// <summary>
    /// 
    /// </summary>
    public bool IsReusable { get; private set; }

    /// <summary>
    /// Creates a new instance of the slice this definition represents.
    /// </summary>
    /// <returns>The slice instance.</returns>
    /// <exception cref="InvalidOperationException">Thrown if the slice requires a model.</exception>
    public RazorSlice CreateSlice() => HasModel
        ? throw new InvalidOperationException($"Slice {SliceType.Name} requires a model of type {ModelType?.Name}. Call Create<TModel>(TModel model) instead.")
        : IsReusable ? GetReusableInstance() : ((Func<RazorSlice>)Factory)();

    /// <summary>
    /// Creates a new instance of the slice this definition represents with the specified model.
    /// </summary>
    /// <typeparam name="TModel">The type of the slice model.</typeparam>
    /// <param name="model">The model for the slice.</param>
    /// <returns>The slice instance.</returns>
    /// <exception cref="InvalidOperationException">Thrown if the slice does not require a model or the model instance passed is not assignable to the model type the slice requires.</exception>
    public RazorSlice<TModel> CreateSlice<TModel>(TModel model) => !HasModel || !typeof(TModel).IsAssignableTo(ModelType)
        ? throw new InvalidOperationException($"""
            Cannot use model of type {typeof(TModel).Name} with slice {SliceType.Name}.
            {(HasModel ? $"Ensure the model is assignable to {ModelType!.Name}" : "It is not a strongly-typed slice.")}
            """)
        : IsReusable ? GetReusableInstance(model) : (RazorSlice<TModel>)((Func<object, RazorSlice>)Factory)(model!);

    private RazorSlice GetReusableInstance()
    {
        Debug.Assert(IsReusable);

        _reusableInstances ??= new();

        if (_reusableInstances.TryDequeue(out var instance))
        {
            return instance;
        }

        var slice = ((Func<RazorSlice>)Factory)();

        Debug.Assert(slice is IRazorReusableSlice);
        slice.ReturnAction = ReturnReusableInstance;

        return slice;
    }

    private RazorSlice<TModel> GetReusableInstance<TModel>(TModel model)
    {
        Debug.Assert(IsReusable);

        _reusableInstances ??= new();

        if (_reusableInstances.TryDequeue(out var instance))
        {
            Debug.WriteLine($"Re-using slice instance of type '{SliceType}'");
            return (RazorSlice<TModel>)instance;
        }

        var slice = (RazorSlice<TModel>)((Func<object, RazorSlice>)Factory)(model!);

        Debug.Assert(slice is IRazorReusableSlice);
        slice.ReturnAction = ReturnReusableInstance;

        return slice;
    }

    internal void ReturnReusableInstance(RazorSlice slice)
    {
        Debug.Assert(IsReusable);
        Debug.Assert(slice is IRazorReusableSlice);

        if (((IRazorReusableSlice)slice).TryReset())
        {
            Debug.WriteLine($"Will reuse slice instance of type '{SliceType}' as the call to TryReset() returned true");
            _reusableInstances?.Enqueue(slice);
            return;
        }

        Debug.WriteLine($"Will not reuse slice instance of type '{SliceType}' as the call to TryReset() returned false");
    }
}

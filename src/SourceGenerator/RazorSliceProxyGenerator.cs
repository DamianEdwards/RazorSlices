using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace RazorSlices.SourceGenerator;

[Generator]
internal class RazorSliceProxyGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var assemblyName = context.CompilationProvider.Select(static (compilation, _) => compilation.AssemblyName);

        var rootNamespace = context.AnalyzerConfigOptionsProvider.Select(static (options, _) =>
            options.GlobalOptions.TryGetValue("build_property.RootNamespace", out var rootNamespace) ? rootNamespace : null);

        var projectDirectory = context.AnalyzerConfigOptionsProvider.Select(static (options, _) =>
            options.GlobalOptions.TryGetValue("build_property.MSBuildProjectDirectory", out var projectDir) ? projectDir : null);

        var sealSliceProxies = context.AnalyzerConfigOptionsProvider.Select(static (options, _) =>
            options.GlobalOptions.TryGetValue("build_property.RazorSliceProxiesSealed", out var sealSliceProxiesValue)
                && bool.TryParse(sealSliceProxiesValue, out var result) && result);

        // (Left.Left          , (Left.Right.Left.Left     , (Left.Right.Right.Left, Left.Right.Right.Right))
        // (string assemblyName, (string rootNamespace     , (string projectDirectory, bool sealSliceProxies))
        var projectInfo = assemblyName.Combine(rootNamespace.Combine(projectDirectory.Combine(sealSliceProxies)));

        // Collect all .cshtml files (both slices and _ViewImports)
        var allCshtmlFiles = context.AdditionalTextsProvider
            .Where(text => text.Path.EndsWith(".cshtml", StringComparison.OrdinalIgnoreCase));

        // Filter to only slice files (GenerateRazorSlice=true)
        var sliceTexts = allCshtmlFiles
            .Combine(context.AnalyzerConfigOptionsProvider)
            .Select((pair, _) =>
            {
                var (additionalText, optionsProvider) = pair;
                var textOptions = optionsProvider.GetOptions(additionalText);
                var generateSlice = textOptions.TryGetValue("build_metadata.RazorGenerate.GenerateRazorSlice", out var generateRazorSliceValue)
                                        && bool.TryParse(generateRazorSliceValue, out var result) && result;

                return (additionalText, generateSlice);
            })
            .Where(file => file.generateSlice)
            .Select((file, _) => file.additionalText);

        // Combine: projectInfo + sliceTexts + allCshtmlFiles (for _ViewImports) + compilation
        // NOTE: Combining with CompilationProvider means Execute re-runs on every C# source change.
        // A future optimization could separate .cshtml parsing into an earlier equatable pipeline
        // stage, so only type resolution runs when the compilation changes.
        var combined = projectInfo
            .Combine(sliceTexts.Collect())
            .Combine(allCshtmlFiles.Collect())
            .Combine(context.CompilationProvider);

        context.RegisterSourceOutput(combined, static (spc, pair) =>
        {
            var projectInfo = pair.Left.Left.Left;
            var sliceTexts = pair.Left.Left.Right;
            var allCshtmlFiles = pair.Left.Right;
            var compilation = pair.Right;

            Execute(spc,
                projectInfo.Left,
                projectInfo.Right.Left,
                projectInfo.Right.Right.Left,
                projectInfo.Right.Right.Right,
                sliceTexts,
                allCshtmlFiles,
                compilation);
        });
    }

    private static void Execute(
        SourceProductionContext context,
        string? assemblyName,
        string? rootNamespace,
        string? projectDirectory,
        bool sealSliceProxies,
        ImmutableArray<AdditionalText> sliceTexts,
        ImmutableArray<AdditionalText> allCshtmlFiles,
        Compilation compilation)
    {
        if (string.IsNullOrEmpty(rootNamespace) || string.IsNullOrEmpty(projectDirectory))
        {
            // Need to have a root namespace and project directory to generate the code
            return;
        }

        var distinctTexts = sliceTexts.Distinct();

        if (!distinctTexts.Any())
        {
            // Nothing to do yet
            return;
        }

        // Build _ViewImports map once for all slices
        var viewImportsMap = ViewImportsResolver.BuildViewImportsMap(allCshtmlFiles);

        HashSet<string> generatedClasses = [];

        var codeBuilder = new StringBuilder();

        codeBuilder.AppendLine("// <auto-generated/>");
        codeBuilder.AppendLine();
        codeBuilder.AppendLine("using global::System.Diagnostics.CodeAnalysis;");
        codeBuilder.AppendLine("using global::RazorSlices;");
        codeBuilder.AppendLine();
        codeBuilder.AppendLine("#nullable enable");
        codeBuilder.AppendLine();

        foreach (var file in distinctTexts)
        {
            var fileName = Path.GetFileNameWithoutExtension(file.Path);
            var directory = Path.GetDirectoryName(file.Path);
            var relativeFilePath = PathUtils.GetRelativePath(projectDirectory!, file.Path);
            var relativeDirectoryPath = PathUtils.GetRelativePath(projectDirectory!, directory);
            var subNamespace = relativeDirectoryPath == "."
                ? ""
                : relativeDirectoryPath.Replace(Path.DirectorySeparatorChar, '.');

            var className = fileName;

            if (!CSharpHelpers.IsValidTypeName(className))
            {
                className = CSharpHelpers.CreateValidTypeName(className);
            }

            if (!string.IsNullOrEmpty(subNamespace) && !CSharpHelpers.IsValidNamespace(subNamespace))
            {
                subNamespace = CSharpHelpers.CreateValidNamespace(subNamespace);
            }

            var subNamespaceAsClassName = subNamespace.Replace('.', '_');
            var fullNamespace = string.IsNullOrEmpty(subNamespace)
                ? rootNamespace
                : $"{rootNamespace}.{subNamespace}";

            // Duplicate class name check
            if (generatedClasses.Contains($"{fullNamespace}.{className}"))
            {
                // TODO: Add an integer suffix to the class name so it can be generated and then log a warning?
                var descriptor = new DiagnosticDescriptor(
                    "RSG0001",
                    "Duplicate Class Name",
                    $"Generated class with name {className} already exists. File '{relativeFilePath}' has been ignored.",
                    "Naming",
                    DiagnosticSeverity.Warning,
                    true);

                context.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None));
            }
            else
            {
                generatedClasses.Add($"{fullNamespace}.{className}");

                // Resolve directives (including _ViewImports hierarchy)
                var sourceText = file.GetText();
                string? resolvedModelType = null;
                bool hasModel = false;

                if (sourceText is not null)
                {
                    var directives = ViewImportsResolver.ResolveDirectives(file.Path, projectDirectory!, viewImportsMap, sourceText);

                    if (directives.InheritsDirective is not null)
                    {
                        var modelTypeName = RazorDirectiveParser.ExtractModelType(directives.InheritsDirective);
                        if (modelTypeName is not null)
                        {
                            resolvedModelType = ModelTypeResolver.ResolveModelType(
                                modelTypeName, directives.UsingDirectives, compilation, rootNamespace);

                            if (resolvedModelType is not null)
                            {
                                hasModel = true;
                            }
                            else
                            {
                                // Report diagnostic for unresolvable model type
                                var descriptor = new DiagnosticDescriptor(
                                    "RSG0002",
                                    "Unresolvable Model Type",
                                    $"Could not resolve model type '{modelTypeName}' for slice '{relativeFilePath}'. The generated proxy will not have a strongly-typed Create method.",
                                    "TypeResolution",
                                    DiagnosticSeverity.Warning,
                                    true);
                                context.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None));
                            }
                        }
                    }
                }

                codeBuilder.AppendLine($$"""
                    namespace {{fullNamespace}}
                    {
                    """);

                var generatedTypeName = string.IsNullOrEmpty(subNamespaceAsClassName)
                    ? className
                    : $"{subNamespaceAsClassName}_{className}";

                var sealedValue = sealSliceProxies ? "sealed " : "partial ";
                var genericParameter = hasModel && resolvedModelType is not null ? $"<{resolvedModelType}>" : "";

                codeBuilder.AppendLine($$"""
                        /// <summary>
                        /// Static proxy for the Razor Slice defined in <c>{{relativeFilePath}}</c>.
                        /// </summary>
                        public {{ sealedValue }}class {{className}} : global::RazorSlices.IRazorSliceProxy{{genericParameter}}
                        {
                            [global::System.Diagnostics.CodeAnalysis.DynamicDependency(global::System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All, TypeName, "{{assemblyName}}")]
                            private const string TypeName = "AspNetCoreGeneratedDocument.{{generatedTypeName}}, {{assemblyName}}";
                            [global::System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(global::System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.All)]
                            private static readonly global::System.Type _sliceType = global::System.Type.GetType(TypeName)
                                ?? throw new global::System.InvalidOperationException($"Razor view type '{TypeName}' was not found. This is likely a bug in the RazorSlices source generator.");
                            private static readonly global::RazorSlices.SliceDefinition _sliceDefinition = new(_sliceType);
                    """);

                if (hasModel && resolvedModelType is not null)
                {
                    codeBuilder.AppendLine($$"""
                            /// <summary>
                            /// Creates a new instance of the Razor Slice defined in <c>{{relativeFilePath}}</c> with the given model.
                            /// </summary>
                            public static global::RazorSlices.RazorSlice<{{resolvedModelType}}> Create({{resolvedModelType}} model) => _sliceDefinition.CreateSlice<{{resolvedModelType}}>(model);

                            // Explicit interface implementation, workaround for https://github.com/dotnet/runtime/issues/102796
                            static global::RazorSlices.RazorSlice<{{resolvedModelType}}> global::RazorSlices.IRazorSliceProxy<{{resolvedModelType}}>.CreateSlice({{resolvedModelType}} model) => Create(model);
                    """);
                }
                else
                {
                    codeBuilder.AppendLine($$"""
                            /// <summary>
                            /// Creates a new instance of the Razor Slice defined in <c>{{relativeFilePath}}</c>.
                            /// </summary>
                            public static global::RazorSlices.RazorSlice Create() => _sliceDefinition.CreateSlice();

                            // Explicit interface implementation, workaround for https://github.com/dotnet/runtime/issues/102796
                            static global::RazorSlices.RazorSlice global::RazorSlices.IRazorSliceProxy.CreateSlice() => Create();
                    """);
                }

                // Close class & namespace
                codeBuilder.AppendLine("""
                        }
                    }
                    """);

                codeBuilder.AppendLine();
            }
        }

        context.AddSource($"{rootNamespace}.RazorSliceProxies.g.cs", SourceText.From(codeBuilder.ToString(), Encoding.UTF8));
    }
}
